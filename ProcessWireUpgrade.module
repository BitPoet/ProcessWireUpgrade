<?php

/**
 * Tool to Upgrade ProcessWire Core
 *
 * ProcessWire 2.x 
 * Copyright (C) 2014 by Ryan Cramer 
 * Licensed under GNU/GPL v2, see LICENSE.TXT
 * 
 * http://processwire.com
 *
 */

class ProcessWireUpgrade extends Process {

	/**
	 * Return information about this module (required)
	 *
	 */
	public static function getModuleInfo() {
		return array(
			'title' => 'Core Upgrade', 
			'summary' => 'Upgrade ProcessWire core to latest master or dev version automatically in the admin.', 
			'version' => 1, 
			'author' => 'Ryan Cramer', 
			); 
	}

	const pageName = 'core-upgrade';

	/**
	 * Info for the branches that we can install
	 *
	 */
	protected $branches = array(
		'stable' => array(
			'name' => 'stable', 
			'zip' => 'https://github.com/ryancramerdesign/ProcessWire/archive/master.zip',
			'ver' => 'https://raw.githubusercontent.com/ryancramerdesign/ProcessWire/master/wire/core/ProcessWire.php'
			), 
		'dev' => array(
			'name' => 'dev', 
			'zip' => 'https://github.com/ryancramerdesign/ProcessWire/archive/dev.zip',
			'ver' => 'https://raw.githubusercontent.com/ryancramerdesign/ProcessWire/dev/wire/core/ProcessWire.php',
			)
		);

	/**
	 * Path to /wire/
	 *
	 */
	protected $wirePath = '';

	/**
	 * Temporary path used by installer for download and ZIP extraction
	 *
	 */
	protected $tempPath = '';

	/**
	 * Temporary path used by installer for file storage when file system isn't writable
 	 *
	 */
	protected $cachePath = '';

	/**
	 * Array of renames (oldPath => newPath) scheduled for __destruct
	 *
	 */
	protected $renames = array(); // scheduled renames to occur after page render

	/**
	 * Construct
	 *
	 */
	public function __construct() {
		$this->wirePath = $this->config->paths->root . 'wire/';
		$this->tempPath = $this->config->paths->cache . $this->className() . '/';
		$this->cachePath = $this->config->paths->cache . 'core-upgrade/';
		parent::__construct();
	}

	public function init() {
		parent::init();
	}

	/**
	 * Get the current version associated with the selected branch
	 *
	 */
	protected function getBranchVersion($branch) {
		$info = $this->branches[$branch]; 
		$http = new WireHttp();
		$data = $http->get($info['ver']); 
		if(empty($data)) throw new WireException("Unable to load $info[ver]"); 

		if(!preg_match_all('/const\s+version(Major|Minor|Revision)\s*=\s*(\d+)/', $data, $matches)) {
			throw new WireException("Unable to find version information from branch."); 
		}

		$version = array();
		foreach($matches[1] as $key => $name) {
			$version[$name] = (int) $matches[2][$key];
		}

		$out = "$version[Major].$version[Minor].$version[Revision]";
		$this->session->set('ProcessWireUpgrade_newVersion', $out); 
		$this->session->set('ProcessWireUpgrade_oldVersion', $this->config->version); 

		return $out; 
	}

	/**
	 * Determine the branch from a GET variable and return info array
	 *
	 */
	protected function getBranch() {
		$branch = $this->input->get('branch'); 
		if(empty($branch) || !isset($this->branches[$branch])) $this->session->redirect($this->page->url); 
		return $this->branches[$branch]; 
	}

	/**
	 * Ask user to select branch or make them remove existing installation files
	 *
	 */
	public function execute() {

		if(file_exists($this->cachePath) || file_exists($this->tempPath)) {
			$out = "<h2>Upgrade files are already present. Please remove them before continuing.</h2>";
			$btn = $this->modules->get('InputfieldButton'); 
			$btn->href = "./remove";
			$btn->value = $this->_('Remove'); 
			$out .= $btn->render();
			return $out; 
		}

		$out = "<h2>Please select a branch</h2><p>";
		foreach($this->branches as $name => $info) {
			$btn = $this->modules->get('InputfieldButton'); 
			$btn->href = "./check?branch=$name";
			$btn->icon = 'code-fork';
			$btn->value = ucfirst($name); 
			$out .= $btn->render();
		}
		$out .= "</p>";

		return $out; 
	}

	/**
	 * Remove existing installation files
	 *
	 */
	public function executeRemove() {
		if(wireRmdir($this->cachePath, true)) $this->message("Removed $this->cachePath"); 
		if(wireRmdir($this->tempPath, true)) $this->message("Removed $this->tempPath"); 
		$this->session->redirect("./"); 
	}

	/**
	 * Check the selected branch and compare to current version to see if user wants to continue
	 *
	 */
	public function executeCheck() {

		$branch = $this->getBranch();
		$branchVersion = $this->getBranchVersion($branch['name']); 
		$currentVersion = $this->config->version; 
		$result = version_compare($currentVersion, $branchVersion);

		if($result < 0) { 
			$this->message("The version found ($branchVersion) is newer than the one you currently have ($currentVersion)"); 

		} else if($result > 0) {
			$this->message("The version found ($branchVersion) is older than the one you currently have ($currentVersion)"); 

		} else {
			$this->message("The version found is the same as the one you currently have"); 
		}

		$out = "<h2>Do you want to download and install version $branchVersion?</h2>";
		$btn = $this->modules->get('InputfieldButton'); 
		$btn->href = "./download?branch=$branch[name]";
		$btn->value = $this->_('Download Now'); 
		$btn->icon = 'cloud-download';
		$out .= $btn->render();

		return $out; 
	}

	/**
	 * Download the selected branch ZIP file
	 *
	 */
	public function executeDownload() {

		$out = '';
		$error = '';
		$branch = $this->getBranch();
		$newVersion = $this->session->ProcessWireUpgrade_newVersion;

		wireMkdir($this->tempPath); 
		$http = new WireHttp();
		$zipfile = $http->download($branch['zip'], $this->tempPath . "$branch[name].zip"); 

		if(!$zipfile || !file_exists($zipfile) || !filesize($zipfile)) {
			throw new WireException("Unable to download $branch[zip]"); 
		}

		$out = "<h2>Downloaded version $newVersion (" . number_format(filesize($zipfile)) . " bytes)</h2>"; 
		$btn = $this->modules->get('InputfieldButton'); 
		$btn->href = "./prepare?branch=$branch[name]";
		$btn->value = $this->_('Continue'); 
		$btn->icon = 'angle-right';
		$out .= $btn->render();

		return $out; 		
		
	}

	/**
	 * Unzip files and prepare them for installation
	 *
	 */
	public function executePrepare() {

		$error = '';
		$branch = $this->getBranch();
		$zipfile = $this->tempPath . "$branch[name].zip";

		$oldVersion = $this->session->ProcessWireUpgrade_oldVersion;
		$newVersion = $this->session->ProcessWireUpgrade_newVersion;

		$cacheUpgradePath = $this->cachePath;
		$rootPath = dirname(rtrim($this->wirePath, '/')) . '/'; 
		$rootTempPath = $this->tempPath; 
		$wireTempPath = $this->tempPath . 'wire/'; 
		$wireNewName = "wire-$newVersion";

		$indexFile = $rootPath . "index.php";
		$htaccessFile = $rootPath . ".htaccess";
		$indexNewName = "index-$newVersion.php";
		$htaccessNewName = "htaccess-$newVersion.txt";

		if(is_writable($rootPath)) {
			$rootWritable = true; 
			$wireNewPath = $rootPath . $wireNewName . "/";
			$htaccessNewFile = $rootPath . $htaccessNewName; 
			$indexNewFile = $rootPath . $indexNewName;
		} else {
			$rootWritable = false;
			$cacheUpgradeURL = str_replace($this->config->paths->root, '/', $cacheUpgradePath); 
			$this->error("Your web root path is not writable, so we are installing files to $cacheUpgradeURL instead. You will have to copy them manually to your web root."); 
			wireMkdir($cacheUpgradePath); 
			$wireNewPath = $cacheUpgradePath . 'wire/';
			$htaccessNewFile = $cacheUpgradePath . 'htaccess.txt';
			$indexNewFile = $cacheUpgradePath . 'index.php';
		}

		if(!file_exists($zipfile)) throw new WireException("Unable to locate ZIP: $zipfile"); 
		$files = wireUnzipFile($zipfile, $this->tempPath); 
		if(!count($files)) $error = "No files were found in $zipfile";

		if(!$error && !is_dir($wireTempPath)) {
			// adjust paths according to where they were unzipped, as needed
			// need to drill down a level from extracted archive
			$rootTempPath = $this->tempPath . trim($files[0], '/') . '/';
			$wireTempPath = $rootTempPath . "wire/";
		}

		$indexTempFile = $rootTempPath . "index.php"; 
		$htaccessTempFile = $rootTempPath . "htaccess.txt";
		$indexTempFile = $rootTempPath . 'index.php';
		$htaccessTempFile = $rootTempPath . 'htaccess.txt';

		if(!$error && !is_dir($wireTempPath)) $error = "Unable to find /wire/ directory in archive"; 	

		if(!$error) {

			$renames = array(
				$wireTempPath => $wireNewPath, 
				$indexTempFile => $indexNewFile, 
				$htaccessTempFile => $htaccessNewFile,
				);

			foreach($renames as $old => $new) {

				$_old = str_replace($this->config->paths->root, '/', $old); 
				$_new = str_replace($this->config->paths->root, '/', $new); 

				if(!file_exists($old)) {
					$this->error("$_old does not exist"); 
					continue; 
				}

				if(file_exists($new)) {
					$this->message("$_new already exists"); 
					continue; 
				}
				
				if(rename($old, $new)) {
					$this->message("Copied $_old => $_new"); 
				} else {
					$this->error("Unable to rename $_old => $_new"); 
				}
			}
		}

		wireRmdir($this->tempPath, true); 

		if($error) {
			throw new WireException($error); 

		} else {
			$out = 	"<h2>Upgrade files copied</h2>" . 
			 	"<p class='description'>We have prepared copies of upgrade files for installation. At this point, " . 
				"you may install them yourself by replacing the existing <u>/wire/</u> directory, and " . 
				"optionally <u>index.php</u> and <u>.htaccess</u> files with the new versions indicated.</p>"; 

			if($rootWritable) {
				$out .= "<h2>Install upgrade files?</h2>" . 
					"<p class='description'>Check the boxes below for what you'd like us to install. " . 
					"Since <u>.htaccess</u> files may have site-specific customizations, you may " .
					"consider handling that one manually, unless you know it hasn't been modified.</p>";

				$out .= "<form action='./install/' method='post'><div class='InputfieldContent'>" . 
					"<p>" . 
					"<label><input type='checkbox' name='wire' value='1' /> Install new core /wire/ directory " . 
					"<span class='detail'>(old will be renamed to /.wire-$oldVersion/)</span></label><br />" . 
					"<label><input type='checkbox' name='index' value='1' /> Install new index.php file " . 
					"<span class='detail'>(old will be renamed to .index-$oldVersion.php)</span></label><br />" . 
					"<label><input type='checkbox' name='htaccess' value='1' /> Install new .htaccess file " . 
					"<span class='detail'>(old will be renamed to .htaccess-$oldVersion)</span></label>" . 
					"<p>";

				$btn = $this->modules->get('InputfieldSubmit');
				$btn->attr('name', 'submit_install');
				$btn->value = $this->_('Install'); 
				$btn->icon = 'angle-right';
				$out .= $btn->render(); 
				$out .= "</div></form>";

			} else {
				$renames = array(
					"<u>/wire/</u>" => "<u>/.wire-$oldVersion/</u> <span class='detail'>(as a backup)</span>", 
					"<u>/index.php</u>" => "<u>/.index-$oldVersion.php</u> <span class='detail'>(as a backup)</span>", 
					"<u>/.htaccess</u>" => "<u>/.htaccess-$oldVersion</u> <span class='detail'>(as a backup)</span>", 
					"<u>$wireNewPath</u>" => "<u>/wire/</u>",
					"<u>$indexNewFile</u>" => "<u>/index.php</u><span class='detail'>*</span>", 
					"<u>$htaccessNewFile</u>" => "<u>/.htaccess</u> <span class='detail'>*</span>", 
					);

				$out .= "<h2>Unable to install upgrade files</h2>" . 
					"<p class='description'>Your file system is not writable so we can't automatically " . 
					"install the upgrade files for you. However, the files are ready for you to move to " .
					"their destinations. Please do the following:</p>" . 
					"<ul>";
				foreach($renames as $old => $new) {
					$old = str_replace($this->config->paths->root, '/', $old); 
					$out .= "<li>Rename $old to $new</li>";
				}
				$out .= "</ul>";
			}

			$out .= "<p class='detail'>*In many cases, it is not necessary to upgrade the <u>index.php</u> " . 
				"and <u>htaccess</u> files since they don't always change between versions.</p>";

		}

		return $out; 
	}

	/**
	 * Install prepared files
	 *
	 */
	public function executeInstall() {

		if(!$this->input->post('submit_install')) throw new WireException('No form received'); 
		$oldVersion = $this->session->ProcessWireUpgrade_oldVersion;
		$newVersion = $this->session->ProcessWireUpgrade_newVersion;
		$rootPath = dirname(rtrim($this->wirePath, '/')) . '/'; 
		$renames = array();

		if($this->input->post('wire')) {
			$renames["wire"] = ".wire-$oldVersion";
			$renames["wire-$newVersion"] = "wire";
		}
		if($this->input->post('index')) {
			$renames["index.php"] = ".index-$oldVersion.php";
			$renames["index-$newVersion.php"] = "index.php";
		}
		if($this->input->post('htaccess')) { 
			$renames[".htaccess"] = ".htaccess-$oldVersion";
			$renames["htaccess-$newVersion.txt"] = ".htaccess";
		}

		foreach($renames as $old => $new) {
			$this->rename($rootPath . $old, $rootPath . $new); 
		}

		$out = "<h2>Upgrade completed</h2>";					
		$out .= "<p>Now double check that everything works before you leave this page.</p>"; 
		$out .= "<p><a target='_blank' href='{$this->config->urls->root}'>Test Site</a><br />" . 
			"<a target='_blank' href='{$this->config->urls->admin}'>Test Admin</a></p>"; 
		$out .= "<p class='description'><strong>If something does not work:</strong> try reloading the page 1 or " . 
			"2 more times, as it may take a couple of requests before the system completes internal " . 
			"adjustments. If it still doesn't work, manually restore the backup files " . 
			"as mentioned in the messages above.</p>";

		return $out; 
	}

	/**
	 * Schedule a rename operation, which will occur at __destruct
	 *
	 */
	protected function rename($oldPath, $newPath) {
		$this->renames[$oldPath] = $newPath; 
		$old = basename(rtrim($oldPath, '/')); 
		$new = basename(rtrim($newPath, '/')); 
		$this->message("Rename $old => $new"); 
	}

	/**
	 * Process rename operations
	 *
	 */
	public function __destruct() {
		if(!count($this->renames)) return;
		$rootPath = dirname(rtrim($this->wirePath, '/')) . '/'; 
		foreach($this->renames as $oldPath => $newPath) {
			if(file_exists($newPath)) {	
				$n = 0;
				do { $newPath2 = $newPath . "-" . (++$n); } while(file_exists($newPath2)); 
				if(rename($newPath, $newPath2)) $this->message("Renamed $newPath => $newPath2"); 
			}
			$old = basename(rtrim($oldPath, '/')); 
			$new = basename(rtrim($newPath, '/')); 
			if(rename($oldPath, $newPath)) {
				$this->message("Renamed $old => $new"); 
			} else {
				$this->error("Unable to rename $old => $new"); 		
			}
		}
		$this->renames = array();
	}

	/**
	 * Install
	 *
	 */
	public function ___install() {

		// create the page our module will be assigned to
		$page = new Page();
		$page->template = 'admin';
		$page->name = self::pageName; 

		// installs to the admin "Setup" menu ... change as you see fit
		$page->parent = $this->pages->get($this->config->adminRootPageID)->child('name=setup');
		$page->process = $this; 

		// we will make the page title the same as our module title
		// but you can make it whatever you want
		$info = self::getModuleInfo();
		$page->title = $info['title'];

		// save the page
		$page->save();

		// tell the user we created this page
		$this->message("Created Page: {$page->path}"); 
	}

	/**
	 * Uninstall
	 *
	 */
	public function ___uninstall() {

		// find the page we installed, locating it by the process field (which has the module ID)
		// it would probably be sufficient just to locate by name, but this is just to be extra sure.
		$moduleID = $this->modules->getModuleID($this); 
		$page = $this->pages->get("template=admin, process=$moduleID, name=" . self::pageName); 

		if($page->id) {
			// if we found the page, let the user know and delete it
			$this->message("Deleting Page: {$page->path}"); 
			$page->delete();
		}

		wireRmdir($this->tempPath, true); 
	}

}

